# 处理边界情况
## 访问元素&组件
### 访问根实例
    this.$root.foo
>这里的foo可以是根实例中的数据，也可以修改数据，也可以计算属性，调用的方法
### 访问父级组件实例
    this.$parent.xxx
        类似于$root
### 访问子组件实例或子元素
    在模板中给子元素 使用ref绑定id
    父组件可以通过$refs.id访问到这个元素
#### ref 和 v-for 一起使用的时候
    得到的引用将会是一个包含了对应数据源的这些子组件的数组
        具体的访问可以通过控制台具体调节
### 依赖注入
    父组件使用provide声明，子组件使用inject接收
>可以把依赖注入看作一部分“大范围有效的 prop”
    与Prop不同的是：
        祖先组件不需要知道哪些后代组件使用它提供的属性
        后代组件不需要知道被注入的属性来自哪里
## 程序化的事件侦听器
>不是太懂
## 循环引用
### 递归组件
    当你使用 Vue.component 全局注册一个组件时，这个全局的 ID 会自动设置为该组件的 name 选项。
    在组件内部调用name 则可以调用自己
        稍有不慎，递归组件就可能导致无限循环
        请确保递归调用是条件性的
### 组件之间的循环引用
    A引用B，B引用A
>有些问题，用到的时候再来解决，现在还不懂webpack
## 模板定义的替代品
### 内联模板：不推荐
    inline-template这个属性出现在组件上时，组件里面的内容将会作为模板
    缺点：会让模板的作用域变得更加难以理解
        最好是组件内优先选择 template 选项或 .vue 文件里的一个 <template> 元素来定义模板。
### X-Template
    在script元素中，type给定为text/x-template，然后指定一个id
    在像平时定义template时:template:"#id"
    适用于：模板特别大的demo，或者极小型的应用，其他情况避免使用
## 控制更新
### 强制更新
    如果你发现你自己需要在 Vue 中做一次强制更新
    一般就是你某个地方做错了
        你可能还没有留意到数组或对象的变更检测注意事项
        你可能依赖了一个未被 Vue 的响应式系统追踪的状态。
    那么你可以通过 $forceUpdate 来做这件事。
### 通过 v-once 创建低开销的静态组件
    大量的静态内容需要使用，这种情况可以在根组件上添加v-once
    千万不要随意使用，因为带有这个属性的模板无法更新
